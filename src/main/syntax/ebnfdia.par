/~
EBNF Parser written in JS/CC
mpo@outerthought.org - 2010
~/

/~
snatched from: http://karmin.ch/ebnf/index

"EBNF defined in itself" {
	syntax     = [ title ] "{" { production } "}" [ comment ].
	production = identifier "=" expression ( "." | ";" ) .
	expression = term { "|" term } .
	term       = factor { factor } .
	factor     = identifier
	           | literal
	           | "[" expression "]"
	           | "(" expression ")"
	           | "{" expression "}" .
	identifier = character { character } .
	title      = literal .
	comment    = literal .
	literal    = "'" character { character } "'"
	           | '"' character { character } '"' .
	}
~/

[*
;
// node structs
function Syntax(set, title, comment) {
	this.set = set;
	this.title = title;
	this.comment = comment;
}
Syntax.prototype.visualize = function() {
	print(this.toString());
};
Syntax.prototype.toString = function() {
	return "-- " + this.title + " --\n-------------------------------------" + this.set + "\n----------------------------------------\ncomment:\n" + this.comment;
}

var PRODUCTION_SET = { 
	"label": "\n@@\n", 
	"join": function(i) { 
		return  "\n" + i + "| ";
	}
};
var TERM_SET       = { 
	"label": "", 
	"join": function(i) { 
		return (i==0) ? "" : "|";
	}
};
var FACTOR_SET       = { 
	"label": "", 
	"join": function(i) { 
		return "";
	}
};
function Set(t) {
	this.type = t;
	this.children = new Array();
}
Set.prototype.addChild = function(node) {
	this.children.push(node);
};;
Set.prototype.toString = function() {
	var cnt = this.children.length;
	var o = this.type.label;
	for (var i = 0; i < cnt; i++)
		o += this.type.join(i) + this.children[i].toString();
	return o;
}


function Production(id, expr) {
	this.id = id;
	this.expr = expr;
}
Production.prototype.toString = function(ind) {
	ind = ind || "";
	return ind + this.id + "=" + this.expr + " ." ;
}

function Identifier(id) {
	this.id = id;
}
Identifier.prototype.toString = function() {
	return this.id;
};


function Literal(txt) {
	this.txt = txt;
}
Literal.prototype.toString = function() {
	return "\"" + this.txt + "\"";
};


function Optional(set) {
	this.set = set;
}
Optional.prototype.toString = function() {
	return "[" + this.set + "]";
};


function Repeating(set) {
	this.set = set;
}
Repeating.prototype.toString = function() {
	return "{" + this.set + "}";
};


function Group(set) {
	this.set = set;
}
Group.prototype.toString = function() {
	return "(" + this.set + ")";
};



// node factories
function createNode(type, childs)  {
	var children = new Array();
	
	for( var i = 2; i < arguments.length; i++ )
		children.push( arguments[i] );

	return new Node(type, children);
};

function createSyntax(set, title, comment) {
	return new Syntax(set, title, comment);
};

function createSet() {
	return new Set(PRODUCTION_SET);
}

function createProduction(id, expr) {
	return new Production(id, expr);
}

function createExpression() {
	return new Set(TERM_SET);
}

function createTerm() {
	return new Set(FACTOR_SET);
}

function createIdentifier(id) {
	return new Identifier(id);
}

function createLiteral(txt) {
	return new Literal(txt);
}

function createOptional(termset) {
	return new Optional(termset);
}

function createRepeating(termset) {
	return new Repeating(termset);
}

function createGroup(termset) {
	return new Group(termset);
}

// main execution code
function visualize(node) {
	node.visualize();
};

*]

/~  Tokens to be ignored (whitespace and comments)	
~/
!       ' |\r|\n|\t'
        ;

/~ Grammar tokens				
~/
        '='
        ','
        '\|'
        '\{'
        '\}'
        '\['
        '\]'
        '\('
        '\)'
        '\.|;'						Terminator
        '[A-Za-z_][A-Za-z0-9_]*'   			Identifier
        '(\'([^\'\\]|\\.)*\')|(\"([^\"]|\\.)*\")'	Literal		[* ;
        			%match = %match.substr( 1, %match.length - 2 );
        			%match = %match.replace(/\\\'/g,"\'").replace(/\\\"/g,"\"").replace(/\\\\/g,"\\");
        								*]
        ;
##

/~ root is where it all starts
~/
root:        syntax          				[* visualize(%1);                           			*]
		|
                ;
/~ syntax is basically set of productions optionally decorated with title and comment
~/
syntax:         Literal '{' productionset '}' Literal	[* %% = createSyntax( %3, %1, %5); 				*]
                | Literal '{' productionset '}'		[* %% = createSyntax( %3, %1); 					*]
                | '{' productionset '}' Literal		[* %% = createSyntax( %2, undefined, %4);			*]
                | '{' productionset '}'			[* %% = createSyntax( %2); 					*]
                ;


/~ productionset is the recurring of at least one production
~/
productionset:  production				[* %% = createSet(); %%.addChild(%1);				*]
		| productionset production		[* %% = %1; %%.addChild(%2);					*]
		;


/~ production is the actual named syntax-statement to plot out 
~/
production:     Identifier '=' expression Terminator	[* %% = createProduction(%1, %3);		 		*]
		;


/~ expressions build up the production
~/
expression:     term					[* %% = createExpression(); %%.addChild(%1);			*]
		| expression "|" term  			[* %% = %1; %%.addChild(%3); 					*]
		;

/~ terms make up the possible chosen paths in expressions
~/
term:           factor 					[* %% = createTerm(); %%.addChild(%1); 				*]
		| term factor				[* %% = %1; %1.addChild(%2);					*]
		;
				
/~ factors make up the sequential stuff in terms
~/
factor:         Identifier				[* %% = createIdentifier(%1);					*]
                | Literal				[* %% = createLiteral(%1);					*]
                | "[" expression "]"			[* %% = createOptional(%2);					*]
                | "{" expression "}"			[* %% = createRepeating(%2);					*]
                | "(" expression ")"			[* %% = createGroup(%2);					*]
                ;

[*

function open_file( file )
{
	var fs = new ActiveXObject( 'Scripting.FileSystemObject' );	
	var src = new String();

	if( fs && fs.fileExists( file ) )
	{
		var f = fs.OpenTextFile( file, 1 );
		if( f )
		{
			src = f.ReadAll();
			f.Close();
		}
	}
	
	return src;
}

function read_string()
{
   var kbd = new java.io.BufferedReader(
   		new java.io.InputStreamReader( java.lang.System[ "in" ] ) );

   return kbd.readLine();
}

function read_file( file )
{
	var src = new String();
	
	if( ( new java.io.File( file ).exists() ) )
		src = readFile( file );
	else
	{
		print( "unable to open file '" + file + "'" );
		quit();
	}
	
	return src;
}

if( arguments.length > 0 )
{
	var str			= read_file( arguments[0] );
	var error_cnt 	= 0;
	var error_off	= new Array();
	var error_la	= new Array();
	
	if( ( error_cnt = __##PREFIX##parse( str, error_off, error_la ) ) > 0 )
	{
		var i;
		for( i = 0; i < error_cnt; i++ )
			print( "Parse error near >" 
				+ str.substr( error_off[i], 30 ) + "<, expecting \"" + error_la[i].join() + "\"" );
	}
}
else
{
	print( 'usage: ebnfdia.js <filename>' );
}
*]
